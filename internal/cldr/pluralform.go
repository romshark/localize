// Package cldr provides Plural-Form headers
// for all languages that can be used in .po files.
package cldr

import (
	_ "embed"
	"encoding/json"
	"fmt"

	"golang.org/x/text/language"
)

// Generated by https://github.com/php-gettext/Languages
//
//go:embed languages.json
var languagesJSON []byte

var (
	byBase map[language.Base]PluralForms
	byTag  map[language.Tag]PluralForms
)

func init() {
	var m map[string]struct {
		Cases   []string `json:"cases"`
		Plurals int      `json:"plurals"`
		Formula string   `json:"formula"`
	}
	if err := json.Unmarshal(languagesJSON, &m); err != nil {
		// Should never happen. If this happens, it means
		// github.com/php-gettext/Languages provided unexpected results.
		panic(fmt.Errorf("unmarshaling languages.json: %w", err))
	}

	byBase = make(map[language.Base]PluralForms, len(byTag))
	byTag = make(map[language.Tag]PluralForms, len(byTag))
	for k, v := range m {
		t, err := language.Parse(k)
		if err != nil {
			panic(fmt.Errorf("parsing language BCP 47: %w", err))
		}

		p := PluralForms{
			GettextFormula: v.Formula,
			GettextPluralForms: fmt.Sprintf(
				"nplurals=%d; plural=%s", v.Plurals, v.Formula,
			),
			CardinalForms: make([]CLDRPluralForm, v.Plurals),
		}
		for i, c := range v.Cases {
			switch c {
			case "zero":
				p.Cardinal.Zero = true
				p.CardinalForms[i] = CLDRPluralFormZero
			case "one":
				p.Cardinal.One = true
				p.CardinalForms[i] = CLDRPluralFormOne
			case "two":
				p.Cardinal.Two = true
				p.CardinalForms[i] = CLDRPluralFormTwo
			case "few":
				p.Cardinal.Few = true
				p.CardinalForms[i] = CLDRPluralFormFew
			case "many":
				p.Cardinal.Many = true
				p.CardinalForms[i] = CLDRPluralFormMany
			case "other":
				p.Cardinal.Other = true
				p.CardinalForms[i] = CLDRPluralFormOther
			}
		}
		byTag[t] = p

		base, _ := t.Base()
		byBase[base] = p
	}
}

type PluralForms struct {
	CardinalForms      []CLDRPluralForm
	GettextFormula     string
	GettextPluralForms string
	Cardinal           CLDRForms
}

type CLDRForms struct{ Zero, One, Two, Few, Many, Other bool }

type CLDRPluralForm uint8

const (
	_ CLDRPluralForm = iota

	CLDRPluralFormZero
	CLDRPluralFormOne
	CLDRPluralFormTwo
	CLDRPluralFormFew
	CLDRPluralFormMany
	CLDRPluralFormOther
)

func (p CLDRPluralForm) String() string {
	switch p {
	case CLDRPluralFormZero:
		return "Zero"
	case CLDRPluralFormOne:
		return "One"
	case CLDRPluralFormTwo:
		return "Two"
	case CLDRPluralFormFew:
		return "Few"
	case CLDRPluralFormMany:
		return "Many"
	case CLDRPluralFormOther:
		return "Other"
	}
	return ""
}

// ByBase returns the PluralForms corresponding to locale.
func ByBase(base language.Base) (f PluralForms, ok bool) {
	f, ok = byBase[base]
	return f, ok
}

// ByTag returns the PluralForms corresponding to locale.
func ByTag(locale language.Tag) (f PluralForms, ok bool) {
	f, ok = byTag[locale]
	return f, ok
}
