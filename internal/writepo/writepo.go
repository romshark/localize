// Package writepo provides functions to marshal catalogs into
// gettext compatible .po files.
package writepo

import (
	"fmt"
	"io"
	"iter"
	"strings"
	"time"

	"github.com/romshark/localize/internal/codeparser"
	"github.com/romshark/localize/internal/pluralform"
	"golang.org/x/text/language"
)

// WriteCatalog writes a .po file.
func WriteCatalog(
	w io.Writer, locale language.Tag, catalog *codeparser.Catalog,
) {
	pluralForms := pluralform.ByTag(locale)

	// Header
	if catalog.CopyrightNotice != "" {
		fmt.Fprintf(w, "# %s\n", catalog.CopyrightNotice)
	}

	// Metadata block
	fmt.Fprintln(w, `msgid ""`)
	fmt.Fprintln(w, `msgstr ""`)
	if !catalog.LastRevision.DateTime.IsZero() {
		formatted := catalog.LastRevision.DateTime.Format(time.RFC3339)
		fmt.Fprintf(w, "\"PO-Revision-Date: %s\"\n", formatted)
	}
	if catalog.LastRevision.Translator != "" {
		fmt.Fprintf(w, "\"Last-Translator: %s\"\n", catalog.LastRevision.Translator)
	}
	if catalog.BugsReportEmail != "" {
		fmt.Fprintf(w, "\"Report-Msgid-Bugs-To: <%s>\"\n", catalog.BugsReportEmail)
	}
	fmt.Fprintf(w, "\"Language: %s\\n\"\n", locale)
	fmt.Fprintln(w, "\"MIME-Version: 1.0\\n\"")
	fmt.Fprintln(w, "\"Content-Type: text/plain; charset=UTF-8\\n\"")
	fmt.Fprintln(w, "\"Content-Transfer-Encoding: 8bit\\n\"")
	fmt.Fprintf(w, "\"Plural-Forms: %s\\n\"\n", pluralform.ByTag(locale).GettextFormula)
	fmt.Fprint(w, "\"X-Generator: "+
		"https://github.com/romshark/localize/cmd/localize\\n\"\n\n")

	for msg, meta := range catalog.Ordered() {
		for _, p := range meta.Pos {
			fmt.Fprintf(w, "#: %s:%d:%d\n", p.Filename, p.Line, p.Column)
		}

		fmt.Fprintf(w, "#. hash: %q\n", msg.Hash)
		if msg.Description != "" {
			for l := range iterateLines(msg.Description) {
				fmt.Fprintf(w, "#. %s\n", l)
			}
		}

		fmt.Fprintf(w, "msgid %q\n", msg.Other)

		switch msg.FuncType {
		case codeparser.FuncTypePlural, codeparser.FuncTypePluralBlock:
			fmt.Fprintf(w, "msgid_plural %q\n", msg.Other)
			for i, f := range pluralForms.Forms {
				var txt string
				switch f {
				case "zero":
					txt = msg.Zero
				case "one":
					txt = msg.One
				case "two":
					txt = msg.Two
				case "few":
					txt = msg.Few
				case "many":
					txt = msg.Many
				case "other":
					txt = msg.Other
				default:
					panic("unknown case: %q")
				}
				fmt.Fprintf(w, "msgstr[%d] %q\n", i, txt)
			}
		default:
			// Other
			fmt.Fprintf(w, "msgstr %q\n", msg.Other)
		}
		fmt.Fprintln(w)
	}
}

// WriteTemplate writes a .pot file
func WriteTemplate(
	w io.Writer, locale, origLocale language.Tag, catalog *codeparser.Catalog,
) {
	fmt.Fprint(w, "# Generated by romshark/localize/cmd/extract. DO NOT EDIT.\n")
	fmt.Fprintf(w, "# language: %q\n\n", locale)

	for msg, meta := range catalog.Messages {
		_ = msg
		for _, p := range meta.Pos {
			fmt.Fprintf(w, "# %s:%d:%d\n", p.Filename, p.Line, p.Column)
		}

		fmt.Fprintf(w, "# %s:", origLocale)
		// if cldrPluralFormsCardinal.Zero && m.Zero != "" {
		// 	fmt.Fprint(w, "zero = \"\"\n")
		// }
		// if cldrPluralFormsCardinal.One {
		// 	fmt.Fprint(w, "one = \"\"\n")
		// }
		// if cldrPluralFormsCardinal.Two {
		// 	fmt.Fprint(w, "two = \"\"\n")
		// }
		// if cldrPluralFormsCardinal.Few {
		// 	fmt.Fprint(w, "few = \"\"\n")
		// }
		// if cldrPluralFormsCardinal.Many {
		// 	fmt.Fprint(w, "many = \"\"\n")
		// }

		// fmt.Fprintf(w, "[%s]\n", messageHash(msg.Text, msg.Description))
		// if msg.Description != "" {
		// 	for l := range iterateLines(msg.Description) {
		// 		fmt.Fprintf(w, "description = %q\n", msg.Description)
		// 	}
		// }

		// if msg.FuncType == codeparser.FuncTypeCardinal {
		// 	if cldrPluralFormsCardinal.Zero {
		// 		fmt.Fprint(w, "zero = \"\"\n")
		// 	}
		// 	if cldrPluralFormsCardinal.One {
		// 		fmt.Fprint(w, "one = \"\"\n")
		// 	}
		// 	if cldrPluralFormsCardinal.Two {
		// 		fmt.Fprint(w, "two = \"\"\n")
		// 	}
		// 	if cldrPluralFormsCardinal.Few {
		// 		fmt.Fprint(w, "few = \"\"\n")
		// 	}
		// 	if cldrPluralFormsCardinal.Many {
		// 		fmt.Fprint(w, "many = \"\"\n")
		// 	}
		// }

		// Other
		fmt.Fprint(w, "other = \"\"\n\n")
	}
}

func iterateLines(s string) iter.Seq[string] {
	return func(yield func(string) bool) {
		for {
			i := strings.IndexByte(s, '\n')
			if i == -1 {
				if !yield(s) {
					break
				}
				return
			}
			if !yield(s[:i]) {
				break
			}
			s = s[i+1:]
		}
	}
}
