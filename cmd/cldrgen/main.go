package main

import (
	"bytes"
	_ "embed"
	"encoding/json"
	"flag"
	"fmt"
	"log"
	"os"
	"sort"

	"mvdan.cc/gofumpt/format"
)

// Copied from:
// https://github.com/unicode-org/cldr-json/blob/main/cldr-json/cldr-core/supplemental/plurals.json
//
//go:embed plurals_cardinal.json
var pluralsCardinalJSON []byte

// Copied from:
// https://github.com/unicode-org/cldr-json/blob/main/cldr-json/cldr-core/supplemental/ordinals.json
//
//go:embed plurals_ordinal.json
var pluralsOrdinalJSON []byte

type ModelCardinal struct {
	Supplemental struct {
		Version struct {
			UnicodeVersion string `json:"_unicodeVersion"`
			CLDRVersion    string `json:"_cldrVersion"`
		} `json:"version"`
		PluralsTypeCardinal map[string]struct {
			Zero  string `json:"pluralRule-count-zero,omitempty"`
			One   string `json:"pluralRule-count-one,omitempty"`
			Two   string `json:"pluralRule-count-two,omitempty"`
			Few   string `json:"pluralRule-count-few,omitempty"`
			Many  string `json:"pluralRule-count-many,omitempty"`
			Other string `json:"pluralRule-count-other,omitempty"`
		} `json:"plurals-type-cardinal"`
	} `json:"supplemental"`
}

type ModelOrdinal struct {
	Supplemental struct {
		Version struct {
			UnicodeVersion string `json:"_unicodeVersion"`
			CLDRVersion    string `json:"_cldrVersion"`
		} `json:"version"`
		PluralsTypeOrdinal map[string]struct {
			Zero  string `json:"pluralRule-count-zero,omitempty"`
			One   string `json:"pluralRule-count-one,omitempty"`
			Two   string `json:"pluralRule-count-two,omitempty"`
			Few   string `json:"pluralRule-count-few,omitempty"`
			Many  string `json:"pluralRule-count-many,omitempty"`
			Other string `json:"pluralRule-count-other,omitempty"`
		} `json:"plurals-type-ordinal"`
	} `json:"supplemental"`
}

func main() {
	fOutFile := flag.String("outfile", "cldr.go", "output file path")
	fPackageName := flag.String("package", "cldr", "package name")
	flag.Parse()

	b := new(bytes.Buffer)

	var modelCardinal ModelCardinal
	if err := json.Unmarshal(pluralsCardinalJSON, &modelCardinal); err != nil {
		log.Fatalf("unmarshaling plurals_cardinal.json: %v", err)
	}

	var modelOrdinal ModelOrdinal
	if err := json.Unmarshal(pluralsOrdinalJSON, &modelOrdinal); err != nil {
		log.Fatalf("unmarshaling plurals_ordinal.json: %v", err)
	}

	fmt.Fprint(b, "// Code generated by github.com/romshark/localize/cmd/cldrgen."+
		" DO NOT EDIT.\n")
	fmt.Fprintf(b, "//  Unicode version: %s\n",
		modelCardinal.Supplemental.Version.UnicodeVersion)
	fmt.Fprintf(b, "//  CLDR version: %s\n\n",
		modelCardinal.Supplemental.Version.CLDRVersion)

	fmt.Fprintf(b, "package %s\n\n", *fPackageName)

	fmt.Fprint(b, "type PluralForms struct{ Zero, One, Two, Few, Many bool }\n")

	// Write map lang -> PluralForms (cardinal)
	fmt.Fprint(b, "var PluralFormsCardinalByLanguage = map[string]PluralForms {\n")
	for _, l := range sortedKeys(modelCardinal.Supplemental.PluralsTypeCardinal) {
		p := modelCardinal.Supplemental.PluralsTypeCardinal[l]
		fmt.Fprintf(b, "%q: {", l)
		if p.Zero != "" {
			fmt.Fprint(b, "Zero: true,")
		}
		if p.One != "" {
			fmt.Fprint(b, "One: true,")
		}
		if p.Two != "" {
			fmt.Fprint(b, "Two: true,")
		}
		if p.Few != "" {
			fmt.Fprint(b, "Few: true,")
		}
		if p.Many != "" {
			fmt.Fprint(b, "Many: true,")
		}
		fmt.Fprint(b, "},\n")
	}
	fmt.Fprint(b, "}\n")

	// Write map lang -> PluralForms (ordinal)
	fmt.Fprint(b, "var PluralFormsOrdinalByLanguage = map[string]PluralForms {\n")
	for _, l := range sortedKeys(modelOrdinal.Supplemental.PluralsTypeOrdinal) {
		p := modelOrdinal.Supplemental.PluralsTypeOrdinal[l]
		fmt.Fprintf(b, "%q: {", l)
		if p.Zero != "" {
			fmt.Fprint(b, "Zero: true,")
		}
		if p.One != "" {
			fmt.Fprint(b, "One: true,")
		}
		if p.Two != "" {
			fmt.Fprint(b, "Two: true,")
		}
		if p.Few != "" {
			fmt.Fprint(b, "Few: true,")
		}
		if p.Many != "" {
			fmt.Fprint(b, "Many: true,")
		}
		fmt.Fprint(b, "},\n")
	}
	fmt.Fprint(b, "}\n")

	// Write map lang -> expressions
	fmt.Fprint(b, "var CLDR = map[string]PluralForms {\n")
	for _, l := range sortedKeys(modelOrdinal.Supplemental.PluralsTypeOrdinal) {
		p := modelOrdinal.Supplemental.PluralsTypeOrdinal[l]
		fmt.Fprintf(b, "%q: {", l)
		if p.Zero != "" {
			fmt.Fprint(b, "Zero: true,")
		}
		if p.One != "" {
			fmt.Fprint(b, "One: true,")
		}
		if p.Two != "" {
			fmt.Fprint(b, "Two: true,")
		}
		if p.Few != "" {
			fmt.Fprint(b, "Few: true,")
		}
		if p.Many != "" {
			fmt.Fprint(b, "Many: true,")
		}
		fmt.Fprint(b, "},\n")
	}
	fmt.Fprint(b, "}\n")

	// Format and write to file.
	formatted, err := format.Source(b.Bytes(), format.Options{})
	if err != nil {
		log.Fatalf("formatting generated code: %v", err)
	}

	{
		f, err := os.OpenFile(*fOutFile, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0o644)
		if err != nil {
			log.Fatalf("opening output file: %v", err)
		}

		if _, err := f.Write(formatted); err != nil {
			log.Fatalf("writing formatted code to file: %v", err)
		}
	}
}

func sortedKeys[V any](m map[string]V) []string {
	keys := make([]string, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	sort.Strings(keys)
	return keys
}
